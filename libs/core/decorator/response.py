import timefrom functools import wrapsfrom core.http.response import HttpResponsefrom utils.log import loggerfrom utils.exceptions import PubErrorCustomclass Core_connector:    def __init__(self,**kwargs):        pass    def __request_validate(self,request,**kwargs):       return kwargs    def __run(self,func,outside_self,request,*args, **kwargs):        res = func(outside_self, request, *args, **kwargs)        if not isinstance(res, dict):            res = {'data': None, 'msg': None, 'header': None}        if 'data' not in res:            res['data'] = None        if 'msg' not in res:            res['msg'] =  {}        if 'header' not in res:            res['header'] = None        return HttpResponse(data= res['data'],headers=res['header'], msg=res['msg'])    def __response__validate(self,outside_self,func,response):        logger.debug('[%s : %s]Training complete in %lf real seconds' % (outside_self.__class__.__name__, getattr(func, '__name__'), self.end - self.start))        return response    def __call__(self,func):        @wraps(func)        def wrapper(outside_self,request,*args, **kwargs):            try:                self.start = time.time()                kwargs=self.__request_validate(request,**kwargs)                response=self.__run(func,outside_self,request,*args, **kwargs)                self.end=time.time()                return self.__response__validate(outside_self,func,response)            except PubErrorCustom as e:                return HttpResponse(success=False, msg=e.msg, data=None)            except Exception as e:                logger.error('[%s : %s  ] : [%s]'%(outside_self.__class__.__name__, getattr(func, '__name__'),str(e)))                return HttpResponse(success=False, msg=str(e), data=None)        return wrapper